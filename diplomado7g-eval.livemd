# Entrega iOSLab diplomado

```elixir
Mix.install([
  {:req, "~> 0.4.8"},
  {:req_github_oauth, "~> 0.1.1"},
  {:kino_explorer, "~> 0.1.11"}
])
```

## Section

```elixir
repo = "iOSLabUNAM/SwiftUIBasics"
req = Req.new(http_errors: :raise) |> ReqGitHubOAuth.attach()
```

```elixir
issues =
  1..4
  |> Task.async_stream(fn page ->
    Req.get!(req, url: "https://api.github.com/repos/#{repo}/issues?page=#{page}&per_page=50").body
  end)
  |> Stream.map(fn {:ok, res} -> res end)
  |> Enum.to_list()
  |> List.flatten()
  |> Enum.filter(fn iss -> is_nil(iss["closed_at"]) && is_nil(iss["pull_request"]) end)
  |> Enum.map(fn iss ->
    %{
      id: iss["number"],
      title: iss["title"]
    }
  end)
```

```elixir
prs =
  1..4
  |> Task.async_stream(fn page ->
    Req.get!(req, url: "https://api.github.com/repos/#{repo}/pulls?page=#{page}&per_page=50").body
  end)
  |> Stream.map(fn {:ok, res} -> res end)
  |> Enum.to_list()
  |> List.flatten()
  |> Enum.filter(fn pr -> is_nil(pr["closed_at"]) end)
```

```elixir
students =
  prs
  |> Enum.map(fn x -> x["user"]["url"] end)
  |> Enum.uniq()
  |> Task.async_stream(fn url ->
    res = Req.get!(req, url: url).body

    %{
      id: res["id"],
      name: res["name"],
      username: res["login"],
      email: res["email"],
      bio: res["bio"]
    }
  end)
  |> Enum.reduce([], fn {:ok, res}, acc -> [res | acc] end)
  |> Enum.uniq()
  |> Enum.filter(fn %{name: name} -> !is_nil(name) end)
```

```elixir
valid_prs =
  prs
  |> Enum.map(fn x ->
    %{
      id: x["number"],
      user_id: x["user"]["id"],
      author: nil,
      body: x["body"],
      url: x["url"],
      html_url: x["html_url"],
      issue_url: x["issue_url"],
      timeline_url: "#{x["issue_url"]}/timeline"
    }
  end)
  |> Enum.filter(fn %{body: body} -> !is_nil(body) end)
  |> Enum.map(fn pr ->
    student = students |> Enum.find(fn x -> x.id == pr.user_id end)

    if is_nil(student) do
      pr
    else
      %{pr | author: student.name}
    end
  end)
```

```elixir
review = fn timeline_url ->
  review_comments = Req.get!(req, url: timeline_url).body

  evals =
    review_comments
    |> Stream.filter(fn %{"event" => event} -> event == "reviewed" end)
    |> Stream.filter(fn %{"author_association" => author} -> author == "MEMBER" end)
    |> Stream.map(fn rev -> rev["body"] end)
    |> Stream.filter(fn body -> String.contains?(body, "LGTM") end)
    |> Enum.map(fn body ->
      [{val, _rem} | _] =
        ~r/[(\d)]/
        |> Regex.scan(body)
        |> List.flatten()
        |> Enum.map(&Integer.parse/1)

      val
    end)

  if length(evals) > 0, do: hd(evals), else: nil
end
```

```elixir
eval =
  students
  |> Enum.map(fn student ->
    student_prs = Enum.filter(valid_prs, fn pr -> pr.user_id == student.id end)

    student_issues =
      issues
      |> Enum.reduce([], fn issue, pr_list ->
        pr =
          Enum.find(student_prs, %{}, fn %{body: body} ->
            String.contains?(body, "##{issue.id}")
          end)

        timeline = Map.get(pr, :timeline_url)
        review = if is_nil(timeline), do: nil, else: review.(timeline)

        [
          %{
            issue: issue.id,
            url: Map.get(pr, :html_url),
            review: review
          }
          | pr_list
        ]
      end)

    Map.put(student, :pull_requests, student_issues)
  end)
```
