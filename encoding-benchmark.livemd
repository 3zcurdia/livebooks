# Url Encoding parameters

```elixir
Mix.install([
  {:benchee, "~> 1.5"},
  {:jason, "~> 1.4"},
  {:kino_benchee, "~> 0.1.1"}
])
```

## Section

```elixir
q_short = %{
  "status2" => "active"
}

q_medium = %{
  "agent_id" => 223456,
  "status2" => "active",
}

q_medium2 = %{
  "search" => "765432123",
  "agent_id" => 223456,
  "status2" => "active",
  "team_id" => [1, 3],
}


q_large = %{
  "search" => "765432123",
  "status2" => "active",
  "agent_id" => 223456,
  "inserted_at" => ~U[2025-11-11 15:02:56.282475Z],
  "last_message_at" => [~U[2025-01-11 00:02:00.333334Z], ~U[2025-11-11 15:02:56.282475Z]],
  "team_id" => [1, 3],
  "priority" => ["low", "medium"],
  "messages_count" => 0.33334
}
```

```elixir
defmodule Encoder do
  def term_encode(input) do
    input
    |> :erlang.term_to_binary(compressed: 9)
    |> Base.url_encode64(padding: false)
  end

  def term_decode(input) do
    input
    |> Base.url_decode64!(padding: false)
    |> :erlang.binary_to_term()
  end
  
  def json_encode(input) do
    input
    |> Jason.encode!()
    |> Base.url_encode64(padding: false)
  end

  def json_decode(input) do
    input
    |> Base.url_decode64!(padding: false)
    |> Jason.decode!()
  end
  
  def json_encode_zip(input) do
    input
    |> Jason.encode!()
    |> :zlib.zip()
    |> Base.url_encode64(padding: false)
  end

  def json_decode_zip(input) do
    input
    |> Base.url_decode64!(padding: false)
    |> :zlib.unzip()
    |> Jason.decode!()
  end
  

  def length_test(input) do
    %{
      term: String.length(term_encode(input)),
      json_encode: String.length(json_encode(input)),
      json_encode_zip: String.length(json_encode_zip(input)),
    }
  end
end
```

```elixir
[] |> Encoder.length_test()
```

```elixir
q_short |> Encoder.length_test()
```

```elixir
q_medium |> Encoder.length_test()
```

```elixir
q_medium2 |> Encoder.length_test()
```

```elixir
q_large |> Encoder.length_test()
```

```elixir
Benchee.run(%{
  "term" => fn input -> Encoder.term_encode(input) end,
  "json" => fn input -> Encoder.json_encode(input) end,
  "json_zip" => fn input -> Encoder.json_encode_zip(input) end
  },
  inputs: %{
    "empty" => [],
    "small" => q_short,
    "medium" => q_medium,
    "medium2" => q_medium2,
    "large" => q_large
  },
  warmup: 2,
  time: 5,
  memory_time: 2,
  reduction_time: 2,
  profile_after: true
)
```

```elixir
Benchee.run(%{
  "term" => fn %{term: input} -> Encoder.term_decode(input) end,
  "json" => fn %{json: input} -> Encoder.json_decode(input) end,
  "json_zip" => fn %{json_zip: input} -> Encoder.json_decode_zip(input) end
  },
  inputs: %{
    "empty" => %{term: Encoder.term_encode([]), json: Encoder.json_encode([]), json_zip: Encoder.json_encode_zip([])},
    "small" => %{term: Encoder.term_encode(q_short), json: Encoder.json_encode(q_short), json_zip: Encoder.json_encode_zip(q_short)},
    "medium" => %{term: Encoder.term_encode(q_medium), json: Encoder.json_encode(q_medium), json_zip: Encoder.json_encode_zip(q_medium)},
    "medium2" => %{term: Encoder.term_encode(q_medium2), json: Encoder.json_encode(q_medium2), json_zip: Encoder.json_encode_zip(q_medium2)},
    "large" => %{term: Encoder.term_encode(q_large), json: Encoder.json_encode(q_large), json_zip: Encoder.json_encode_zip(q_large)}
  },
  warmup: 2,
  time: 5,
  memory_time: 2,
  reduction_time: 2,
  profile_after: true
)
```
